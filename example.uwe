[basics]
id := a -> a;
const := a -> b -> a;
ignore := a -> b -> b;
fix := f -> (x -> f (v -> x x v)) (x -> f (v -> x x v)); [Z combinator]
compose := f -> g -> x -> f (g x);
then := g -> f -> x -> f (g x);
rev := x -> f -> f x;
rev2 := x -> y -> f -> f x y;
if := scottBool;
let := rev;

$ := id;
. := compose;
& := then;

constThunk := x -> thunkify (_ -> x);
constN := fix (self -> n -> x -> if (n `= atoi "0") (constThunk x) (thunkify (_ -> (const `$ self (n `+ atoi "-1") x))));

[maybe]
just := a -> f -> x -> f a;
nothing := f -> x -> force x;
fromMaybe := rev2 id `. constThunk;
scottMaybe := id;

[tuple]
tup := x -> y -> f -> f x y;
fst := rev const;
snd := rev ignore;
scottTuple := id;

[either]
left := x -> f -> g -> f x;
right := x -> f -> g -> g x;
scottEither := id;
isLeft := rev2 (const true) (const false);
isRight := not `. isLeft;
leftToMaybe := rev2 just (const nothing);
rightToMaybe := rev2 (const nothing) just;
fromLeft := leftToMaybe `& fromMaybe "FAIL";
fromRight := rightToMaybe `& fromMaybe "FAIL";

[nTup]
nTup := "TODO";
nTupNth := "TODO";

[nSum]
nSum := "TODO";
nSumGetIdx := "TODO";
nSumIsNth := "TODO";
nSumGetNth := "TODO";
fromNSum := "TODO";

[list]
null := f -> x -> force x;
cons := h -> t -> f -> x -> f h t;
maybeHead := rev2 (h -> t -> just h) (constThunk nothing);
maybeTail := rev2 (h -> t -> just t) (constThunk nothing);
scottList := id;
churchList := l -> f -> x -> fix (self -> l -> l (h -> t -> f h (self t)) (constThunk x)) l;

[list functions, but independent of impl]
head := maybeHead `& fromMaybe "FAIL";
tail := maybeTail `& fromMaybe "FAIL";
reduce := f -> x -> l -> churchList l f (constThunk x);
map := f -> reduce (f `& cons) null;
filter := f -> reduce (h -> r -> if (f h) (thunkify (_ -> cons h r)) (constThunk r)) null;
len := reduce (h -> r -> r `+ atoi "1") (atoi "0");
sum := reduce + (atoi "0");
prod := reduce * (atoi "1");

[uwecode repr]
[expr = lambda string expr | app expr expr | var string | str string | builtin a string appFn:(expr -> expr) subFn:(string -> expr -> expr) ]
[decl = (string, expr)]
lambda := s -> e -> f -> g -> h -> i -> j -> f s e;
app := a -> b -> f -> g -> h -> i -> j -> g a b;
var := s -> f -> g -> h -> i -> j -> h s;
str := s -> f -> g -> h -> i -> j -> i s;
builtin := a -> strRepr -> appFn -> subFn -> f -> g -> h -> i -> j -> j a strRepr appFn subFn;
decl := tup;
scottExpr := id;
scottDecl := scottTuple;

[assumes we're at the top level (no free variables when we start); assumption is untrue when you add global vars TODO]
subst := var -> sub -> fix (self -> expr -> scottExpr expr
  [lambda s e] (s -> e -> lambda s `$ if (var `= s) (constThunk e) (thunkify (_ -> self e)) )
  [app a b] (a -> b -> self a `app self b)
  [var s] (s -> if (var `= s) (constThunk sub) (constThunk expr) )
  [str _] (const expr)
  [builtin a strRepr appFn subFn] (a -> strRepr -> appFn -> subFn -> subFn var sub));

stepExpr := fix (self -> expr -> scottExpr expr
  [lambda _ _] (constN (atoi "2") `$ false `tup expr)
  [app a b] (a -> b -> self a `let (aSimpl ->
               if (fst aSimpl) (thunkify (_ -> (true `tup snd aSimpl `app b))) (thunkify (_ -> (self b `let (bSimpl ->
               if (fst bSimpl) (thunkify (_ -> (true `tup a `app snd bSimpl))) (thunkify (_ -> ( scottExpr a
                   [lambda s e] (s -> e -> true `tup subst s b e)
                   [app _ _] (constN (atoi "2") `$ false `tup a `app b)
                   [var _] (const `$ false `tup a `app b)
                   [str _] (const `$ false `tup a `app b)
                   [builtin x strRepr appFn subFn] (x -> strRepr -> appFn -> subFn -> true `tup appFn b))))))))))
  [var _] (const `$ false `tup expr)
  [str _] (const `$ false `tup expr)
  [builtin _ _ _ _] (constN (atoi "4") `$ false `tup expr));

fullyEvalExpr := fix (self -> expr -> stepExpr expr `let (simpl -> if (fst simpl) (thunkify (_ -> (self `$ snd simpl))) (constThunk `$ snd simpl)));

printExpr := fix (self -> expr -> scottExpr expr
  [lambda s e] (s -> e -> "(" `+ s `+ " -> " `+ self e `+ ")" )
  [app a b] (a -> b -> "(" `+ self a `+ " " `+ self b `+ ")" )
  [var s] (s -> s)
  [str s] (s -> "'" `+ s `+ "'") [ TODO should be double quote and escaped once python is fixed ]
  [builtin a strRepr appFn subFn] (a -> strRepr -> appFn -> subFn -> strRepr));

[parser]

[ symbol: terminal:char | nonterminalIdx: int ]
[ parserRule = possibilities: list (thingsInPossibility: list symbol) ]
[ parserLang = list parserRule ]
[ derivation = (ruleNumTaken:int, derivationsForNonterminals: list derivation) ]
[ parseTable = map (state:int,symbolOrEOF:maybe symbol) (accept:() | reduction:(amtToReduce:int, reduceToNonterminalIdx:int) | transition:int) ]
[ parseState = (state:int, stack (cachedState:int, maybe derivation, symbol)) ]
defaultParseState := atoi "0" `tup null;

[ genParseTable: parserLang -> parseTable ]
genParseTable = "TODO";

[ runParseTable1: parseTable -> parseState -> maybe char -> either (success:bool) (newState:parseState) ]
runParseTable1 := t -> st -> topChr -> scottTODO (mapLookup t (fst st `tup topChr)) [also theres the possibility you find Nothing lol]
  (TODOthunkify? true)
  (reductionInfo -> doReduction reductionInfo st)
  (newStNum -> newStNum `tup push (newStNum `, nothing `, left (fromJust topChr)));

[ runParseTable: parseTable -> strInp:string -> ( errStrIdx:int | derivation ) ]
[BAD runParseTable := t -> fix (self -> state -> str -> scottEither (runParseTable1 t state (maybeHead str)) (TODO) (TODO) ) defaultParseState `. strToList;]
[prob use reduce with a state of (str index,parseState) but my head hurts right now]

[ genParser: parserLang -> (strInp:string -> ( errStrIdx:int | derivation )) ]
genParser := runParseTable `. genParseTable;

exampleLambdaTerm := ((lambda "x" `$ var "x") `app (lambda "x" `$ lambda "y" `$ var "y")) `app (str "q");

main := printExpr `$ fullyEvalExpr exampleLambdaTerm;
